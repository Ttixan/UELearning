## 目录
- 游戏基础技术
- 游戏AI技术
- 游戏AI在Unreal5基础实现
## 游戏基础技术介绍
一个SLG游戏的例子：
有可能不一定是人跟自己打，但实际上是跟AI玩家在竞技。

### 游戏引擎
- 为什么需要游戏引擎？
	- 游戏引擎不是汽车引擎只是给汽车带来动力，而是像一个汽车工厂可以给你提供各种零件和机床让你设计自己的汽车。
- 有哪些游戏引擎？

### AI动画
AI技术？什么是AI
- 教材定义：AI指一个可以观察周遭环境并作出行动以达致成功的系统
需要什么技术
- 动画引擎
- 物理引擎
- 渲染引擎
- 环境感知&行为模型&寻路系统
- GamePlay&系统交互

### 动画系统
动画:游戏AI角色的表现载体，让怪物看起来更真实

### 物理引擎
物理:提供真实世界的感知反馈，为游戏AI角色的增强效果，让AI有更丰富的感知和交互表现
物理引擎还可以做什么？
- 场景查询，AI感知，碰撞检测，事件触发，物理约束模拟，头发模拟，流体模拟等等.

### 引擎渲染
需要进行什么步骤才能渲染出精美的画面？
- 顶点
- 材质贴图
- 平行光
- 其他渲染效果

### 游戏交互系统
UI，设计

### 玩法系统
"Gameplay"是一个非常广泛的概念，它涉及到游戏设计的所有方面，包括战斗，3C，Al，玩家能力等多个模块。
设计一个弓箭系统。需要考虑：
- 动画，连续播放
- ownership等

## 游戏AI技术

### 游戏AI的目的
目的：
1. 提升玩家的游戏代入感以及各种情感
2. 有趣，强度适中，满足玩家心流的挑战
3. 行为合理，没有明显破绽
4. 可能需要“真实

### AI runtime结构
【TODO】

### 游戏AI四大主题
- 环境感知
- 知识管理(记忆)
- 行为模型(决策)
- 寻路

#### 环境感知（Perception）
- 视觉（物理SceneQuery）：看到前面是否有人，敌方友方
- 听觉（Navmesh或者其他数据）：灵通性，物理射线，设定范围（多种实现方法）
- 复杂环境数据转化为方便AI理解的简单中间数据
	- 例如：管子上面可以烘焙其他的数据。
		- 隐体数据。
		- 可攀爬（等
总结：AI需要知道游戏世界上有哪些东西

#### 知识管理（knowledge management）
- 通过黑板（BlackBoard）来数据共享
	- 可以理解为一种记事本，自定义一些变量类型作为数据共享
- 消耗大的感应结果
- 寻路结果
- 分帧Plan的部分Plan结果

#### 行为模型（Behavior Modeling）
- 通过感知记忆，利用逻辑来辅助决策
- 不同的AI需求有不同的最佳应用方案
- 了解核心思路

##### 有限状态机
- 在不同的状态之间相互切换
- 本质：图
- 特点：
	- 原理简单
	- 一个时刻只有一个状态
	- 符合条件时跳转状态

##### 分层有限状态机
在有限状态机的基础上增加了层次结构。它将状态机的状态进行分组，形成不同的层次。
例子：
>以角色扮演游戏(RPG)中的角色行为为例，在顶层可能有“战斗状态”和“非战斗状态“奔这两个大的状态分组。在 “非战斗状态” 这个层次下，又可以细分为 “站立”“行走”跑” 等子状态;在 “战斗状态” 下有 “攻击”“防御”“施法” 等子状态。

##### 行为树
定义：用于描述AI行为逻辑的树状结构模型。通过组合各种类型的节点来构建复杂的行为序列。
- 工作原理: 行为树的执行是从根节点开始，(从上到下，从左到右)根据节点类型和条件来决定如何遍历树结构。
当一个节点被执行时，它会根据自身的功能和返回值来影响行为树的后续执行。行为树侧重于通过组合不同类型的节点(如顺序节点、选择节点等)来构建行为序列。

组成：
- 根节点(Root Node):行为树的起始点，所有的行为逻辑都是从根节点开始向下执行的。例如，在一个游戏角色的行为树中，根节点可能代表 “角色的整体行为控制”
- 控制节点(Control Nodes):
	- 顺序节点(Sequence Node)
	- 选择节点(Selector Node)
	- 并行节点(Parallel Node)
- 行为节点(Action Nodes):这些节点代表具体的行为动作。比如“移动到指定位置”“播放动画”、、“发出声音” 等。行为节点是行为树中实际执行具体操作的部分。以一个宠物游戏中的动物角色为例，行为节点可能包括 “坐下”“打滚”“追逐玩具” 等行为。

#### 寻路系统
##### A\*算法
A\*算法以及其延伸的寻路优化算法是寻路中应用最广泛的。
A\*算法把搜索拆分为了H值和G值搜索优先值F=H+G.
- G值(耗费值):#指从起点走到该点要耗费的值.
- H值(预测值):指从该点走到终点的预测的值(不考虑阻挡的直线距离),复杂的会考虑使用启发函数来计算该值,
搜索的过程也是遍历网格根据规则引人了openlist和closelist去辅助搜索,A\*算法一般情况下效率是比较高的。

##### Navmesh
多边形的寻路系统
简单介绍流程：
- 体素化，做成一个一个的格子
- 区域生成算法：灌水，区域生成
- 生成轮廓：上一步决定
- 创建凸多边形：上一步决定
- 创建细节多边形：三角化。每个突多边形都是三角形组成的

如何进行寻路？还是使用A\*算法，只是从格子改成了多边形。

### 深度学习
#### 基础知识
特征向量：
例子：赚钱和维度向量。

函数求导：变化率
多维函数求导：不好求解。寻找梯度下降的方式接近目标值。

#### 强化学习
马尔可夫决策过程。
- 状态：观测到的信息
- 动作：玩家执行的动作
- 奖励：状态转移过程中获得的奖励
- 策略：状态下执行动作的概率
- 状态转移：执行动作到达状态的概率

## UE5 实战
### 行为树
创建游戏

创建敌人控制器
- 创建新的蓝图

关联敌兵控制器
- 关联上AI conrtoller class 设置为enemy controller

创建敌人行为树
- 创建人工智能-行为树,BT_enemy
- 蓝图脚本Beging play run behavior tree，选择为BT_enemy

运行行为树
- BT添加sequence节点， wait节点
- AI执行

增加巡逻功能：
依赖于Navmesh
- 1.将NavMeshBoundsVolume拖到场景，调整Scale以套住关卡。
- 2.一般会自动构建NavMesh，也可点“Build”键手动构建。
- 3.在关卡视口里按P键可显示隐藏NavMesh(上图绿色部分)
- 4.更多设置也可在RecastNavMesh Actor中设置

黑板字段巡逻目标点
1. 在黑板中增加字段，Kev叫 PatrolLocation，类型是Vector代表位置向量
2. 在行为树中如图增加Move To节点，并且目标点通过Key来引用刚创建好的黑板变量

行为树task
1. 需写自定义逻辑，可通过C++，此通过蓝图Event Script
2. 创建继承自UBTTask BlueprintBase的蓝图类，命名为BP BTTask GetRandomLocation
3. 如图增加逻辑，即当开始执行A1时，在Actor附近10米用NavMesh搜索可达的随机位置，并且设置到黑板变中，并返回本Task的执行结果(成功?失败?)
4. BlackBoard通过新建引用变量传入

使用新建的行为树Task
在行为树上使用task，并且为其参数Blackboard key填入我们需要的patrolocation

### 看到玩家并且互动
- 添加视觉
- 看到玩家
- 打招呼

添加AI视觉感知
在敌人控制器增加AIPerception组件、增加配置Al Sight config，并设为检测所有势力

添加视觉触发器
感知元
在玩家角色BP_ThirdPersonCharacter增加AlPerceptionStimuliSource组件、增加配置AlSense Sight

黑板上添加视觉记忆的字段：目标actor

AI看到玩家打招呼
可以print
也可以选择进行一个打招呼的动画。

### 场景查询
EQS场景查询
创建：人工智能-场景查询

用EQS替代随机位置。
1. 给AI一个随机位置
2. EQS可以帮助AI选择一个更好(经过规则筛选以后的)位置

### 总结
1. 学会原理之后，了解之后改造
2. 是否需要更加真实的设计，有趣的想法？
	1. 行为树的扩展能力
结构问题：
1. 不要为了实现一个玩法而不计代价。
2. 不要粗暴的只管实现，不管制作流程和技术架构
3. 举例:暴力尝试法永远可以正确，但一般都不是最好(较差)的方法。
## 课后作业
1. Al发现玩家以后主动跑到玩家面前来和玩家打一个招呼(各自播放动画)
2. 其他更复杂好玩的想法
