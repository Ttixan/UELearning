## 目录
- 计算机网络基础
- 数据同步基础
- UE网络同步的使用
- UE网络同步的实现

## 计算机网络基础
- 网络通信，什么是Socket
- TCP/UDP区别
- P2P C/S架构

### 计算机网络体系结构
### 分层
- 独立，好维护
- 简化设计
- 标准化
- 灵活，可扩展
- 故障隔离

理解为什么好，而不是每一层具体做了什么？

【TODO：缺一张图】

### Socket
Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

#### Socket通信流程
Socket是“打开-读/写-关闭”模式的实现UDP模式服务器端没有Listen、Accept,客户端没有Connect流程。

### TCP/UDP区别

#### TCP
目的：为了建立网络传输过程的可靠性。
解决方法：三次握手
过程：

> 第一次握手:客户端尝试连接服务器，向服务器发送syn包(同步序列编号Synchronize Sequence Numbers )syn=j，客户端进入SYN_SEND状态等待服务器确认。
> 第二次握手:服务器接收客户端syn包并确认(ack=j+1)同时向客户端发送-个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN RECV状态。
> 第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

#### TCP和UDP的区别
TCP
- 数据传输前需要建立连接
- 提供可靠的字节流服务，提供超时重发，丢弃重复数据，校验数据，流量控制等功能，保证数据能从一端传到另一端
- 对系统资源要求多，协议设计比较复杂，传输存在定的延时
UDP
- 无需建立连接
- 不提供可靠性，不能保证数据到达目的地，没有重发、校验等机制
- 对系统资源要求少，协议设计非常精简，传输速度快

借鉴选择TCP/UDP的原因？
TCP和UDP更上的协议：Http协议。Http2-3，发展变化？基于TCP变为基于UDP的实现。

### P2P C/S 架构
#### P2P
P2P又称点对点，是无中心服务器、依靠用户群(peers )交换信息的互联网体系。对等网络的**每个用户端既是一个节点，也有服务器的功能。**

#### CS架构
C/S架构也称主从式架构，架构分为客户端和服务器，所有客户端只和服务器对连，客户端之间的通信必须通过服务器。软件开发简单，可控性好。但是**服务器性能压力大。**

## 数据同步基础

- RPC是什么，如何实现
- 如何做到对象序列化
- 简单介绍帧同步，状态同步，区别在哪里?各有什么优缺点?

### RPC（远程过程调用）
RPC，即远程过程调用。本地调用远端提供的函数/方法，因为不是一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

逻辑放在不同的地方，

#### RPC实现方法
在远程调用时，我们需要执行的函数体是在远程的机器上的。也就是执行是在另一个进程中。另一端是不知道函数指针和堆栈数据的。
这就带来了几个新问题：
- Call ID映射：
- 序列化和反序列化：把本地结构体，参数，标准化之后以网络数据传输。服务器以同样的方式反序列化。
- 网络传输：调用的效果。

### 对象序列化
问题：调用一个对象如何序列化？
方法：需要某种协议，进行标准化，转化为网络字节流。对方以一样的协议反过来decode。

像函数ID映射一样，本地用到对象实例想要在另一端也能够直接使用,这样会大大简化上层业务逻辑开发，这就需要对象序列化。
对象序列化是将对象转换成一系列字节，这样对象就可以很容易地保存到持久存储中，或者通过通信链路传输。然后可以将字节流反序列化--转换为原始对象的副本。

#### 属性同步
属性同步是对象序列化带来的额外福利，对象A的某个属性更改了,其他端的镜像A对象对应的属性也需要更改，这就是属性同步。属性同步一般是服务器更改，同步到其他所有客户端，主要是为了解决数据冲突和安全性考虑。

#### 游戏网络同步
目的：多个客户端表现效果是一致的。
比喻：好像多个人一起跳街舞，需要动作一致。
额外：需要客户端表现一致。还需要客户端和服务端的数据是一直的。只有网络游戏需要同步。单机游戏不需要。

分类：
- 帧同步
- 状态同步

### 帧同步与状态同步
#### 帧同步
早期用于RTS游戏常用的一种技术。
区别：帧同步只同步操作，大部分游戏逻辑都在客户端，服务器负责广播和验证。
优点：实现简单，数据少，可重播，一致性好。
例子：一个人卡住需要所有人都等着。
手游时代：有一些预表现，可以先预测。如果预测错了再修正。

【TODO：帧同步图片】

#### 状态同步
简而言之：同步的是服务端计算之后的状态。客户端负责收到并且显示。
追求：最终的一致性。只需要每次操作的结果相同即可。

什么是状态同步:同步的是游戏中的各种状态。一般的流程是客户端上传操作到服务器,服务器收到后计算游戏行为的结果然后以广播的方式下发游戏中各种状态，客户端收到状态后再根据状态显示内容。

状态同步其实是一种不严谨的同步。它的思想中，不同玩家屏幕上的表现的一致性并不是重要指标 ，只要每次操作的结果相同即可。所以状态同步对网络延迟的要求并不高，甚至允许一段时间的不一致。

对比：
【TODO：缺一张图】

## UE网络同步

### UE网络架构
- 以“客户端-服务器”模型为基础实现
- 面向对象式封装
- 实现网络代码和游戏逻辑完全分离
- 网络同步支持可视化编程
- 网络协议使用UDP通讯

#### Unreal网络模式
有四种网络模式：
- NM_Standaline：本地运行，单人游戏，或者本地多人游戏
- NM_DedicatedServer：专属服务器，没有玩家。托管多人游戏
- NM_ListernServer：又是客户端，又当服务器、用的不多。
- NM_Client：唯一非服务器模式。只进行监听。

调试方法：
设置Net Mode里面选择哪种模式进行运行。

#### 客户端与服务器连接
如何简历可靠连接的原理：
即使使用UDP实现，也需要类似于TCP进行一些握手。例如校验。

### Actor的复制
Actor是UE网络同步核心。所有的数据同步都是围绕Actor展开的。服务器将保留一份 Actor 列表并定期更新客户端，以便客户端保留每个 Actor(那些需要被同步的Actor)的近似复本。

同步能力
- Creation and Destruction 创建和销毁
- Movement 移动
- **Properties 属性**
- Components 组件
- Subobjects 子对象
- **Remote Procedure Calls(RPC) 远程程序调用**
如何去用：
- 构造函数中，使用bReplicates = true
- 组件：setIsReplicated
- 蓝图：replication属性，设置下面replicates
- component replication属性。

#### Actor role / Remote role
role的权限
- None
- SimulatedProxy（模拟
- AutonomousProxy（主控
- Authority（权威

### 属性复制的规则

- 只支持从服务器复制到客户端，且都是Reliable的
- 在每帧更新完所有Actor的属性状态会执行一遍所有Actor的属性复制只复制那些与上一帧对比发生过变化的属性
- 如果是第一次复制，则复制跟默认值对比不一致的属性
- 只支持复制静态数组，并且只复制数组中与上一帧对比发生过变化的那一项
- 支持复制结构体，结构体中任意属性与上一帧对比发生过变化，都会导致复制结构体的所有属性
- 属性复制支持回调事件

常用：
- OwnerOnly
- 默认广播给所有人？

#### Replicating Object Refernece
同步属性，同步指针，任何复制的actor都可以复制为一个引用。
- 任何未复制的 actor 都必须有可靠命名(直接从数据包加载)
- 任何复制的组件都可以复制为一个引用
- 任何未复制的组件都必须有可靠命名。
- 其他所有 UObject(非 actor 或组件)必须由加载的数据包直接提供

### RPC
函数声明，可靠，不可靠：
- 开火，可靠，需要重发（如果丢包的话）
- 表现事件等，可以设置不可靠。不需要重发。
函数实现：Implement（命名规则？）
- 支持服务器和客户端双向复制
- 可以被标记为:Client、Server、NetMulticast
- 可以是Reliable或者UnReliable的
- 函数复制是没有返回值的，也不支持输出型参数

【TODO：客户端，服务端等调用RPC的表格。】


## DEMO
character
- serverFire
- ApplyDamage
- 更新血量。定义最大血量
	- 定义了replicated，current health
- replicatedUsing，suevival coutnt = 100
- 广播谁击杀了谁

实现函数
- 定义属性没有同步的原因。


## 网络同步的实现
- 网络结构和功能
- 网络相关性
- 常用同分析工具

### Why UDP？
为什么UE使用UDP协议进行实现？
1. TCP可靠但是无法定制。
2. 混合使用：增加了复杂度，有可能相互干扰
3. 使用UDP：
	1. 可以自己定制丢包时候的处理逻辑
	2. 同时兼顾时序性数据和时效性数据。
### 主要类
分层概念。
- NetDriver 网络管理类
	- 驱动整个网络手法
	- 创建管理Netconnection
	- 收发网络Packet
- NetConnection：抽象网络连接
	- 多个netconnection，每个对应一个客户端
	- 创建管理channel
	- 每次通信都是一个packet，每个packet有一个唯一的seq
	- 网络不稳定可能会丢包，会通知channel
- Packet：数据包
- Channel：数据传输的管道
	- 每个NetConnection管理着自己的Channel集合
	- Channel以Bunch为单位进行数据的接收和发送
	- 发送时，Channel将Bunch数据交给NetConnection以Packet发送
	- 接收时，NetConnetion将Bunch分发给对应的Channel进行处理
	- Channel有4种类型ActorChannel.ControlChannel、FileChannel、 VoiceChannel
- Bunch：管道中传输的数据串
	- 数据流通的基本单位
	- 利用每一个bit
	- 可靠或者不可靠。

#### Channel&Bunch
Channel是如何打开的?
> 每个Channel所发送的第一个Bunch，Bunch头部会自动带上Open的标志位以及Channel的类型和序号，通知远端创建对应的Channel。

Channel是如何处理Packet的确认信号的?
> 输出链表，等远端确认收到该Bunch后才从缓存中清除。Channel发送Bunch的同时会将该Bunch复制一份缓存到

以Channel是如何处理Packet丢失的?
> Channel缓存(最多128个)Reliable Bunch，并对丢失Bunch进行重发，确保Reliable Bunch能发送到远端,Channel是如何保证按顺序处理Bunch的?
> Reliable Bunch是带序号的，Channel会缓存收到的不连续的Bunch，确保Bunch能按顺序处理。

Channel是如何关闭的 ?
> 当Channel关闭的时候，它会发送一个独立的空的BunchBunch头部带上了Close的标志位，同时把本地的Channel标志为Closing状态，禁止接收或发送任何数据，等远端收到亥Bunch并返回确认信号后，Channel才会真正地关闭

### Actor相关性

相关性优先级。
例子：视野的优先级。

### Iris replication System
解决服务器性能问题
- 规模
- 人数
- 服务器开销

### 网络分析工具
Network Profiler
- 查看统计数据
- 检索属性和RPC
- 运行时动态开关
Unreal Insights的一部分：network Insights

### 参考资料
- Unreal engine documenti
- exploring in UE
- gaffer on Games
